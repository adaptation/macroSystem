// Generated by CoffeeScript 1.3.3
(function() {
  var PASS_NAME, PEGjsCoffeePlugin, VERSION;

  PASS_NAME = 'compileFromCoffeeScript';

  VERSION = '0.1.0';

  PEGjsCoffeePlugin = function(CoffeeScript) {
    return {
      VERSION: VERSION,
      addTo: function(PEG) {
        var appliedPassNames, index;
        if (CoffeeScript == null) {
          CoffeeScript = global.CoffeeScript;
        }
        PEG.compiler.passes[PASS_NAME] = this.pass;
        appliedPassNames = PEG.compiler.appliedPassNames;
        if (appliedPassNames.indexOf(PASS_NAME) === -1) {
          index = appliedPassNames.indexOf('allocateRegister');
          return appliedPassNames.splice(index - 1, 0, PASS_NAME);
        }
      },
      removeFrom: function(PEG) {
        var appliedPassNames, index;
        appliedPassNames = PEG.compiler.appliedPassNames;
        index = appliedPassNames.indexOf(PASS_NAME);
        if (index > -1) {
          appliedPassNames.splice(index, 1);
          return delete PEG.compiler.passes[PASS_NAME];
        }
      },
      pass: function(ast) {
        var compile, compileCoffeeScript, compileNode, wrappedInitializer;
        compileCoffeeScript = function(code) {
          var compiled, options;
          options = {
            bare: true
          };
          try {
            return compiled = CoffeeScript.compile(code, options);
          } catch (error) {
            throw new SyntaxError("In: \"" + code + "\"\n was the following error: " + error.message, error.fileName, error.lineNumber);
          }
        };
        if (ast.initializer == null) {
          ast.initializer = {
            type: 'initializer',
            code: ''
          };
        }
        wrappedInitializer = "__initializer = ( ->\n  " + ast.initializer.code + "\n  return this\n).call({})";
        ast.initializer.code = compileCoffeeScript(wrappedInitializer);
        compileNode = function(code) {
          var wrappedCode;
          wrappedCode = "return ( -> " + code + " ).apply(__initializer)";
          return compileCoffeeScript(wrappedCode);
        };
        compile = function(nodes) {
          var key, value, _results;
          _results = [];
          for (key in nodes) {
            value = nodes[key];
            if ((value != null) && typeof value === 'object' && value.type !== 'initializer') {
              if (value.code) {
                value.code = compileNode(value.code);
              }
              _results.push(compile(value));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
        return compile(ast);
      }
    };
  };

  (function(define) {
    return define('PEGjsCoffeePlugin', function(require) {
      var CoffeeScript;
      CoffeeScript = require('coffee-script');
      return PEGjsCoffeePlugin(CoffeeScript);
    });
  })(typeof define === 'function' && define.amd ? define : function(id, factory) {
    if (typeof exports !== "undefined" && exports !== null) {
      return module.exports = factory(require);
    } else {
      return window[id] = factory(function(value) {
        return window[value];
      });
    }
  });

}).call(this);
